var e=Object.defineProperty,r=Object.defineProperties,t=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,n=Object.prototype.hasOwnProperty,a=Object.prototype.propertyIsEnumerable,i=(r,t,s)=>t in r?e(r,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):r[t]=s,l=class{constructor({rules:e,queries:r,reverseRules:t}={rules:new Map,queries:new Map,reverseRules:new Map}){var s;this.isDefaultKernelStore=!0,this.runAllQueries=!1,this.execStack=[],this.getSortedID=()=>(l.incrCpt||"undefined"==typeof sessionStorage||(l.sessionCpt=Number(sessionStorage.getItem("adax-sessionCpt"))||0,sessionStorage.setItem("adax-sessionCpt",`${l.sessionCpt+1}`)),`${l.sessionCpt}-${(new Date).getTime().toString(36)}-${l.incrCpt++}`),this.rules=e,this.queries=r,this.reverseRules=t,this.isDefaultKernelStore=!(null==(s=l.instances)?void 0:s.length),l.instances.push(this)}static getAllInstances(){return l.instances}},o=l;o.incrCpt=0,o.sessionCpt=0,o.instances=[];var u=new o,p=({writeFn:e,writeParamsObj:r,queryPlan:t},s={kernel:u})=>{s.kernel.execStack.push({name:e.name,writeFn:e,writeParamsObj:r,queryPlan:t})},c=e=>e===p,d=(e,l,o=[],u=[],p,c,d,v=void 0)=>{var g,h;null==(h=null==(g=e.kernel.queries)?void 0:g.get(c))||h.forEach((e=>{if(!(null==e?void 0:e.readTrigger))return;l.has(c)||l.set(c,new Array);const g=l.get(c),h=v&&v(p,e.paramsObj);var w;e.result=(null==e?void 0:e.result)||{version:0,data:void 0,prevData:void 0,writeFn:void 0,writeParamsObj:void 0},!h&&(null==e?void 0:e.readTrigger)&&(o.push((()=>{((e,r,t,s)=>{e.result.prevData=e.result.data,e.result.data=r(e.paramsObj),e.result.version=e.result.version+1,e.result.writeFn=t,e.result.writeParamsObj=s})(e,c,d,p)})),u.push((()=>{(null==e?void 0:e.readTrigger)&&(e=>{var r,t;(null==(r=e.options)?void 0:r.hasResultChanged)&&!(null==(t=e.options)?void 0:t.hasResultChanged(e.result.prevData,e.result.data))||e.readTrigger(e.result)})(e)}))),g.push((w=((e,r)=>{for(var t in r||(r={}))n.call(r,t)&&i(e,t,r[t]);if(s)for(var t of s(r))a.call(r,t)&&i(e,t,r[t]);return e})({},e),r(w,t({skip:!!h}))))}))},v=u.getSortedID,g=(e,r,t={kernel:u})=>{const{queryPlan:s,computeData:n,triggerViews:a}=(({writeFn:e,writeParamsObj:r},t={kernel:u})=>{const s=new Map,n=[];let a=[];if(!t.kernel.runAllQueries&&t.kernel.rules.has(e)){const i=t.kernel.rules.get(e).readersMap;(null==i?void 0:i.size)&&(null==i||i.forEach(((i,l)=>{d(t,s,n,a,r,l,e,i)}))),t.kernel.queries.size>t.kernel.reverseRules.size&&t.kernel.queries.forEach(((i,l)=>{t.kernel.reverseRules.has(l)||d(t,s,n,a,r,l,e)}))}else c(e)||t.kernel.queries.forEach(((i,l)=>{d(t,s,n,a,r,l,e)}));return{queryPlan:s,computeData:()=>{n.forEach((e=>e()))},triggerViews:()=>{a.forEach((e=>e()))}}})({writeFn:e,writeParamsObj:r},t);e(r),n(),setTimeout((()=>{a(),c(e)||g(p,{writeFn:e,writeParamsObj:r,queryPlan:s},t)}))},h=(e,r,t,s={},n={kernel:u})=>{var a;const i=null!=(a=s.cmpId)?a:v(),l={data:(null==s?void 0:s.skipInitalQuerying)?void 0:r(t),prevData:void 0,version:0,writeFn:void 0,writeParamsObj:void 0};let o=e;if(s.debounceMs||s.throttleMs){if(s.debounceMs&&s.throttleMs)throw new Error("Cannot have both debounce and throttle options for any given query!");s.debounceMs?o=((e,r)=>{let t;return(...s)=>{const n=Array.prototype.slice.call(s);t&&clearTimeout(t),t=setTimeout((()=>{e.apply(void 0,n)}),r)}})(e,s.debounceMs):s.throttleMs&&(o=((e,r)=>{let t,s=0;return(...n)=>{const a=void 0,i=(new Date).getTime(),l=i-s;l<r?(clearTimeout(t),t=setTimeout((()=>{e.apply(a,n)}),r-l)):e.apply(a,n),s=i}})(e,s.throttleMs))}return{result:l,onMounted:()=>{(({queryFn:e,queryInstance:r},t={kernel:u})=>{t.kernel.queries.has(e)||t.kernel.queries.set(e,new Map),t.kernel.queries.get(e).set(r.instanceKey,r)})({queryFn:r,queryInstance:{instanceKey:i,readTrigger:o,paramsObj:{},options:s,result:l}},n)},onBeforeUnmount:()=>{(({queryFn:e,queryInstance:r},t={kernel:u})=>{const s=t.kernel.queries.get(e);s&&(s.delete(r.instanceKey),s.size||t.kernel.queries.delete(e))})({queryFn:r,queryInstance:{instanceKey:i,readTrigger:void 0,paramsObj:{},options:s,result:{data:void 0,prevData:void 0,version:0,writeFn:void 0,writeParamsObj:void 0}}},n)}}};export{h as s,g as t};
